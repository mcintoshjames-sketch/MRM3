# Phase 2 Risk Register

## Audit Summary
**Issues Found:**
- **SEC-01**: P0 overly restrictive (disables endpoint); should be admin-gated with SQL safeguards instead
- **SEC-02**: P0 has two conflicting options; needs single decisive action
- **DATA-01, PERF-01-04, REL-02**: Mislabeled as "P0 (Sprint)" - sprint work is P1, not P0
- **SEC-04**: Acceptance criteria missing startup failure verification
- **REL-01**: Non-standard timeline format ("1-2 days" vs standard windows)

| ID | Severity | Location | The Risk | The Impact | Mitigation Strategy | Proposed Remediation Plan (For Approval) |
| --- | --- | --- | --- | --- | --- | --- |
| SEC-01 | Critical | `api/app/api/analytics.py:21` (`execute_query`) | Executes user-supplied SQL with only a prefix check and no role gating or RLS enforcement. | Data exfiltration, privilege bypass, or destructive multi-statement queries under the app's DB role; hard-to-detect data integrity breaches. | Restrict endpoint to admins or remove in prod; enforce read-only DB role; implement vetted query allowlist with parameterization; block multi-statement execution. | P0 (0–24h): Require `ADMIN` to access the endpoint; enforce DB/session read-only; set `statement_timeout`; cap output size (row limit); add audit logging (actor + query hash + runtime). Keep the existing read-only prefix allowlist; avoid relying on keyword denylists as the primary control.<br>P1 (Sprint): Enforce single-statement execution (block `;`), max query length, and row/column limits; add fuller audit metadata as needed.<br>P2: Move to dedicated read-only DB role/replica; replace with curated analytics endpoints/saved-query templates with parameter binding.<br>Acceptance: Non-admin gets 403; writes denied at DB; query execution is auditable; long/expensive queries are bounded. |
| SEC-02 | Critical | `api/app/api/auth.py:200` (`register`) | Public self-registration accepts `role_code` and can create privileged accounts (including Admin) without any authorization. | Untrusted users can mint admin accounts and take full control of the system. | Require admin-only registration; hard-block privileged roles for self-register; move to SSO-provisioning workflow with audit. | P0 (0–24h): Force server-side role assignment to `USER` only (ignore client-supplied `role_code`).<br>P1 (Sprint): Make registration admin-only with explicit capability check; ensure audit log `user_id` is the acting admin, not the created user.<br>P2: Standardize on Entra/SSO provisioning; remove password-based registration in production builds.<br>Acceptance: No unauthenticated path can create privileged roles; all account creations are attributable to an authorized actor. |
| SEC-03 | High | `api/app/api/auth.py:133` (`list_users`), `api/app/api/auth.py:266` (`update_user`), `api/app/api/auth.py:384` (`delete_user`) | User management endpoints lack role checks; any authenticated user can enumerate users, change roles/passwords, or delete accounts. | Privilege escalation, user takeover, and exposure of PII at scale. | Enforce admin-only access; add capability checks; add audit logging for role changes and deletions. | P0 (0–48h): Gate `list_users/get_user/update_user/delete_user` behind `ADMIN`.<br>P1 (Sprint): Introduce "self-service" update endpoint for current user with field-level allowlist (e.g., password/full_name only); require admin for role/region changes; add audit entries for role changes, password resets, deletions.<br>P2: Add rate limiting + least-PII user lookup endpoint for assignment/search use cases if needed (returns minimal fields).<br>Acceptance: Non-admin cannot enumerate users or mutate other accounts; privileged mutations are logged and reviewable. |
| SEC-04 | High | `api/app/core/config.py:6` (`Settings`) | Insecure defaults (dev secret key, DB credentials, ENVIRONMENT=development) remain active unless env vars are set correctly. | Token forgery, weak auth, and accidental prod deployments with dev credentials. | Fail-fast unless required prod env vars are set; remove default secrets; add startup checks for production hostnames. | P0 (0–72h): Add fail-fast startup checks for production: error if `SECRET_KEY` is missing/too short or equals a known default; error if `DATABASE_URL` points to localhost or uses known dev defaults; require prod to provide explicit env vars.<br>P1 (Sprint): Remove hardcoded secrets from code; provide `.env.example` for dev; update deployment manifests to source secrets from a secret manager; rotate secrets as part of rollout.<br>P2: Add CI/CD policy checks (block deploy if prod env lacks required vars) and runtime telemetry for config drift.<br>Acceptance: Prod cannot start with default secrets/credentials; secret rotation is documented and repeatable. |
| DATA-01 | High | `api/app/api/validation_workflow.py:1945` (`create_validation_request`) | Conflict check for active validations is not atomic; concurrent requests can pass the check and create overlapping active validations. | Duplicate or conflicting validation workflows, broken governance rules, and inconsistent status history. | Add database-level uniqueness/partial indexes for active requests; use transactional locks (SELECT FOR UPDATE) around conflict checks. | P1 (Sprint): Serialize request creation per `model_id` using Postgres advisory locks (or `SELECT ... FOR UPDATE` on the `models` rows) before conflict check + insert; lock model IDs in sorted order to avoid deadlocks (assumes Postgres in prod).<br>P2: Add an invariant-enforcing DB mechanism (trigger or lock table) to prevent >1 active non-targeted validation per model, independent of app logic; add concurrency test harness and monitoring/alerts.<br>Acceptance: Parallel creates cannot yield overlapping active non-targeted validations for the same model set. |
| PERF-01 | High | `api/app/api/kpi_report.py:358` (`_compute_validation_metrics`), `api/app/api/validation_workflow.py:1566` (`calculate_model_revalidation_status`) | KPI report loops over all models and performs multiple DB queries per model; approval status re-calls revalidation status, doubling query load. | KPI report latency grows superlinearly with inventory size; report endpoints time out under production load. | Precompute metrics in batch queries; cache KPI results; batch-load validation status/approval data per model. | P1 (Sprint): Add short-lived caching (per `region_id/team_id`) + request throttling (assumes KPI tolerates ~5–15 min staleness).<br>P2: Replace per-model status functions with set-based SQL queries; consider a materialized view or scheduled job for reusable status across dashboards.<br>Acceptance: KPI endpoint uses O(1) DB round-trips relative to model count; meets agreed SLO under projected inventory size. |
| PERF-02 | Medium | `api/app/api/regional_compliance_report.py:187` (`regional_compliance_report`) | Per-row approval lookup executes an extra query in a loop (N+1). | Report generation slows dramatically as models/regions grow; can saturate DB. | Pre-join approval data in the base query or bulk-fetch approvals into a map. | P1 (Sprint): Bulk-fetch approvals for all `(request_id, region_id)` pairs in a single query and map in memory; add supporting index on `(request_id, region_id, approval_type)` (assumes one approval row per region/request).<br>P2: Fold approvals into the main query via LEFT JOIN and select the relevant approval row (define "latest" rule if multiples exist).<br>Acceptance: Report runs with constant query count; DB load scales primarily with result size, not row-wise lookups. |
| PERF-03 | Medium | `api/app/api/attestations.py:255` (`list_cycles`) | For each cycle, loads all records and computes counts in Python (N+1 + full materialization). | Slow dashboards and memory spikes as attestation history grows. | Aggregate counts in SQL with GROUP BY; paginate cycles. | P1 (Sprint): Replace per-cycle record fetch with SQL aggregates (`COUNT(*)`, `SUM(CASE...)`) grouped by `cycle_id`; add index on `attestation_records(cycle_id, status)`.<br>P2: Add pagination on cycles list and avoid loading historical cycles by default (assumes UI needs "recent" first).<br>Acceptance: Cycles list does not materialize all records; memory and query count remain bounded as history grows. |
| PERF-04 | Medium | `api/app/api/monitoring.py:4112` (`import_cycle_results_csv`), `api/app/api/lob_units.py:659` (`import_lob_csv`) | CSV imports read the entire uploaded file into memory without size limits. | Memory pressure/DoS for large uploads; container OOM under load. | Stream parse CSVs; enforce max upload size; reject overly large files early. | P0 (0–24h, if exposed to untrusted users): Enforce max upload size at ingress + app; reject oversized files with 413 (assumes known safe limits per import type).<br>P1 (Sprint): Stream-parse CSVs (iterate file handle) and process rows incrementally; add max row count + early validation; commit in batches with rollback strategy.<br>P2: For very large imports, move to async/background job with progress tracking and server-side storage.<br>Acceptance: Memory remains bounded; oversized uploads are rejected; large-but-allowed imports complete without OOM. |
| REL-01 | Medium | `api/app/api/monitoring.py:4338` (`import_cycle_results_csv`) | Audit log for bulk import is added after `db.commit()` but never committed. | Missing audit trail for monitoring changes; compliance gaps. | Commit after creating the audit log or include audit log in the same transaction. | P0 (0–48h): Move audit log creation inside the same transaction as the import changes (before commit); if separate commit is required, add a second `db.commit()` after inserting the audit log.<br>P1 (Sprint): Add a regression test that imports (dry_run=false) and asserts an audit log entry exists with correct counts and actor.<br>Acceptance: Every successful import produces exactly one persisted audit log record. |
| REL-02 | Medium | `api/app/api/version_deployment_tasks.py:1160` (`bulk_confirm_deployments`) | Broad exception handling inside a loop without rollback; session can enter failed state after a DB error. | Partial updates, failed commits, and misleading success/failed counts. | Roll back per-failure; use transaction-per-task or bulk operation with savepoints. | P1 (Sprint): Wrap each task update in a savepoint (`begin_nested`) and `rollback` on failure; `flush` per task to surface DB errors early; ensure failures don’t poison the session (assumes partial success is acceptable).<br>P2: Add idempotency/consistency checks and structured error reporting; emit audit log per task success/failure consistently.<br>Acceptance: One task failure does not break the batch; success/failure counts match DB state; no "half-committed" session errors. |
| REL-03 | Medium | `api/app/api/risk_assessment.py:990` (`risk_assessment_pdf`) | Temporary PDF files are created with `delete=False` and never cleaned up. | Disk growth over time leading to degraded performance or outage. | Use `FileResponse` background cleanup or `SpooledTemporaryFile`; schedule temp cleanup. | P0 (0–48h): Add response-time cleanup via `BackgroundTask(os.unlink, tmp_path)` or switch to in-memory streaming (`BytesIO`) to avoid filesystem persistence (assumes PDFs are generated on-demand).<br>P1 (Sprint): Add a periodic `/tmp` cleanup job/cron for defense-in-depth and disk-usage alerting.<br>Acceptance: PDF generation does not leak files; disk usage remains stable under sustained report downloads. |
